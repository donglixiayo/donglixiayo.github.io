<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode刷题笔记（1-10）</title>
    <link href="/2024/03/01/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%881-10%EF%BC%89/"/>
    <url>/2024/03/01/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%881-10%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">2. 两数相加 - 力扣（LeetCode）</a></p><p><strong>Description</strong></p><p>给定两个非空的链表，每个链表节点存储一位数字，整个链表表示两个非负整数（链表从头到尾表示从数字从个位到高位）。</p><p>要求返回两个数字的和，用同样的链表形式。</p><p><strong>Solution</strong></p><p>即实现简单的加法器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pr1</span> <span class="hljs-operator">=</span> l1, pr2 = l2, pr3 = res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span> (pr1 != <span class="hljs-literal">null</span> || pr2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            sum += carry;<br>            <span class="hljs-keyword">if</span> (pr1 != <span class="hljs-literal">null</span>) &#123;<br>                sum += pr1.val;<br>                pr1 = pr1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pr2 != <span class="hljs-literal">null</span>) &#123;<br>                sum += pr2.val;<br>                pr2 = pr2.next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br>            pr3.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            pr3 = pr3.next; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong></p><ul><li>如Solution所示，可以只使用一个<code>while</code>循环。</li></ul><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a></p><p><strong>Description</strong></p><p>给定两个大小不同的数组（已经非严格从大到小排序），返回两个数组中所有元素的中位数。</p><p><strong>Solution</strong></p><ul><li><p>暴力解法：通过遍历合并两个数组，返回结果。时间复杂度为<code>O(m+n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暴力解法，合并两个数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (nums2[n/<span class="hljs-number">2</span>]+nums2[n/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>])/<span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums2[n/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (m % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (nums1[m/<span class="hljs-number">2</span>]+nums1[m/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>])/<span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums1[m/<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> m + n;<br>        <span class="hljs-type">int</span>[] nums3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (pos &lt; length) &#123;<br>            <span class="hljs-keyword">if</span> (i == m) &#123;<br>                <span class="hljs-keyword">while</span> (pos &lt; length) &#123;<br>                    nums3[pos] = nums2[j];<br>                    j++;<br>                    pos++;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == n) &#123;<br>                <span class="hljs-keyword">while</span> (pos &lt; length) &#123;<br>                    nums3[pos] = nums1[i];<br>                    i++;<br>                    pos++;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;<br>                nums3[pos] = nums1[i];<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums3[pos] = nums2[j];<br>                j++;<br>            &#125;<br><br>            pos++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (nums3[length/<span class="hljs-number">2</span>] + nums3[length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>])/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums3[length/<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li><li><p>将问题转换为查找第<code>k</code>小的数，使用二分法，将复杂度降低为<code>log(m+n)</code>：</p><ul><li><p><strong>思路</strong>：我们需要查找第<code>k</code>小的数，可以每次循环排除<code>k/2</code>个数，如何做到：假设我们要寻找第7小的数字：<img src="C:\Users\Belieber\AppData\Roaming\Typora\typora-user-images\image-20240306165302029.png" alt="image-20240306165302029"></p><p>我们比较两个数组第<code>k/2</code>个数字，可以看到第二个数组的3小于第一个数组的4，由此我们可以断定，第二个数组的前k&#x2F;2个数字一定排在第一个数组的第k&#x2F;2个数字之前，即不可能是第k小的数字。所以我们直接将第二个数组的前k&#x2F;2个数字排除：</p><p><img src="C:\Users\Belieber\AppData\Roaming\Typora\typora-user-images\image-20240306165542758.png" alt="image-20240306165542758"></p><p>排除掉3个元素后，我们现在需要从两个新的数组中寻找第7-3也就是第4小的元素（k更新为4）。使用同样的方法，可以排除第一个数组前2个元素：</p><p><img src="C:\Users\Belieber\AppData\Roaming\Typora\typora-user-images\image-20240306165748978.png" alt="image-20240306165748978"></p><p>k更新为2，此时我们只需要再排除1个元素。可以看到，两个数组此时第一个元素相同，我们可以随便选择排除（不妨去掉第二个数组第一个元素）：</p><p><img src="C:\Users\Belieber\AppData\Roaming\Typora\typora-user-images\image-20240306165917898.png" alt="image-20240306165917898"></p><p>k更新为1，即现在我们要找两个数组中第1小的元素，只需要比较两个数组中第一个元素即可。</p></li><li><pre><code class="java">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;        int length1 = nums1.length, length2 = nums2.length;        int k1 = (length1 + length2 + 1) / 2;        int k2 = (length1 + length2 + 2) / 2;        double res = (findKth(nums1, 0, length1-1, nums2, 0, length2-1, k1) +                         findKth(nums1, 0, length1-1, nums2, 0, length2-1, k2))/2;        return res;&#125;// 递归寻找两个数组中第k小的元素private double findKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;        int len1 = end1 - start1 + 1;        int len2 = end2 - start2 + 1;        if (len1 &gt; len2) return findKth(nums2, start2, end2, nums1, start1, end1, k);        if (len1 == 0) return nums2[start2 + k - 1];        if (k == 1) &#123;            return Math.min(nums1[start1], nums2[start2]);        &#125;        int pos1 = start1 + Math.min(k/2, len1) - 1;        int pos2 = start2 + Math.min(k/2, len2) - 1;        if (nums1[pos1] &lt; nums2[pos2]) &#123;            return findKth(nums1, pos1+1, end1, nums2, start2, end2, k-(pos1-start1+1));        &#125; else &#123;            return findKth(nums1, start1, end1, nums2, pos2+1, end2, k-(pos2-start2+1));        &#125;&#125;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-strong">**Tips**</span><br><br><span class="hljs-bullet">+</span> 注意递归结束的条件分两种情况：<br><br><span class="hljs-bullet">  +</span> 情况一：有一个数组长度变为<span class="hljs-code">`0`</span>，此时返回另一个数组的第k个元素即可。<br><span class="hljs-bullet">  +</span> 情况二：<span class="hljs-code">`k == 1`</span>，此时返回两个数组第一个元素中较小的元素。<br><span class="hljs-bullet">  +</span> 情况一必须先于情况二判断，否则将会产生数据越界。<br><br><span class="hljs-bullet">+</span> <span class="hljs-code">```java</span><br><span class="hljs-code">  int k1 = (length1 + length2 + 1) / 2;</span><br><span class="hljs-code">  int k2 = (length1 + length2 + 2) / 2;</span><br><span class="hljs-code">  double res = (findKth(nums1, 0, length1-1, nums2, 0, length2-1, k1) + </span><br><span class="hljs-code">                          findKth(nums1, 0, length1-1, nums2, 0, length2-1, k2))/2;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>这段代码是为了将偶数情况和奇数情况统一，奇数情况下两次调用的函数结果将是相同的。</p><ul><li>例如，<code>nums1</code>长度为3，<code>nums2</code>长度为4，应当查找第4小的元素。此时<code>k1</code>为4，<code>k2</code>也为4。</li><li><code>nums1</code>长度为2，<code>nums2</code>长度为4，应当查找第3小和第4小的元素，并返回平均值。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nSum问题</title>
    <link href="/2024/03/01/nSum%E9%97%AE%E9%A2%98/"/>
    <url>/2024/03/01/nSum%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/submissions/504876230/">1. 两数之和 - 力扣（LeetCode）</a></p><p><strong>Description</strong></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>假定答案有且唯一，注意给定数组无序。</p><p><strong>Solution</strong></p><ul><li>双循环暴力解法</li><li>借助HashMap，寻找目标值：当一次遍历到第<code>i</code>个元素时，问题的关键是寻找值等于<code>target-nums[i]</code>的元素的下标，建立<code>key</code>为值，<code>value</code>为下标的<code>HashMap</code>，通过<code>containsKey()</code>方法判断，并基于值到下标的映射找到原数组下标。</li></ul><p><strong>Tips</strong></p><ul><li>也可以对数组通过<code>Arrays.sort()</code>方法进行排序，参考第8题，但是因为题目要求的是返回下标，所以需要建立<code>value</code>到<code>index</code>的映射。</li></ul><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/submissions/506007132/">15. 三数之和 - 力扣（LeetCode）</a></p><p><strong>Description</strong></p><p>给定一个<code>int</code>数组，返回其中所有<strong>和为<code>0</code><strong>且</strong>不重复</strong>的三元组（数组中的元素可能重复）。</p><p><strong>Solution</strong></p><ul><li><p><code>nSum</code>问题一般都是<strong>先排序</strong>，后双指针：</p><ul><li>外层循环遍历数组确定第一个元素，第一个元素比<code>0</code>大时可以直接返回结果（因为后面的元素全都比<code>0</code>大）。</li><li>内层循环使用双指针，<code>left</code>指向第一个元素之后，<code>right</code>指向数组尾，不断调整<code>left</code>和<code>right</code>，使三个元素之和等于<code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;<br>       Arrays.sort(nums);<br>  <br>       <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>           <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>  <br>           <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过重复元素</span><br>  <br>           <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[i];<br>           <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>, right = len-<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> first + nums[left] + nums[right];<br>               <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                   res.add(Arrays.asList(first, nums[left], nums[right]));<br>                   <span class="hljs-comment">//跳过重复元素，防止重复结果</span><br>                   <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[right-<span class="hljs-number">1</span>]) right--;<br>                   right--;<br>                   <span class="hljs-comment">//跳过重复元素</span><br>                   <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[left]==nums[left+<span class="hljs-number">1</span>]) left++;<br>                   left++;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                   right--;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                   left++;<br>               &#125;<br>           &#125;<br>       &#125;<br>  <br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>Tips</strong></p><ul><li>使用<code>while</code>循环跳过重复元素：<ul><li>第一处：确定第一个元素时，发现这次的第一个元素等于上一次循环确定的第一个元素。</li><li>第二处：三元素和等于<code>0</code>时，将<code>left</code>持续递增跳过重复元素，<code>right</code>持续递减跳过重复元素。</li></ul></li></ul><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><p><strong>Description</strong></p><p>给定<code>int</code>数组，和一个目标值<code>target</code>，要求返回数组中所有和等于<code>target</code>的四元组。<code>nums</code>数组中的元素可能重复，结果集中的四元组不能重复。</p><p><strong>Solution</strong></p><ul><li>将问题分解为每次选择一个元素和一个【三数之和】问题</li></ul><p><strong>Tips</strong></p><ul><li>数组排序后，在选择第一个元素时，不能因为第一个元素大于<code>target</code>而直接返回结果，因为可能有负数元素。（只有当<code>target</code>为<code>0</code>时可以直接返回）</li></ul><h1 id="nSum"><a href="#nSum" class="headerlink" title="*. nSum"></a>*. nSum</h1><p>所有的<code>nSum</code>问题都可以通过递归分解。</p><p>将问题分解为选择一个元素和<code>(n-1)Sum</code>问题，直到<code>n</code>为2。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/02/29/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/02/29/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h2><p><img src="/../images/demo.jpg" alt="测试图片"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/29/hello-world/"/>
    <url>/2024/02/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发（上）</title>
    <link href="/2023/02/01/%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2023/02/01/%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-进程、线程概念"><a href="#1-进程、线程概念" class="headerlink" title="1 进程、线程概念"></a>1 进程、线程概念</h1><ul><li>Java中，启动<code>main</code>函数时其实就是启动了一个JVM进程，<code>main</code>函数所在的线程就是这个进程中的一个线程，也称为主线程。</li><li>一个Java程序的运行是main线程和多个其他线程同时运行。</li><li>同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区资源</strong>，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</li></ul><h2 id="1-1-从JVM角度看进程和线程"><a href="#1-1-从JVM角度看进程和线程" class="headerlink" title="1.1 从JVM角度看进程和线程"></a>1.1 从JVM角度看进程和线程</h2><img src="java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）" style="zoom: 67%;" /><ul><li>线程是进程划分成的更小的运行单位。</li><li>进程是独立的，线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但是不利于资源的管理和保护；进程则恰好相反。</li></ul><p><strong>程序计数器为什么是私有的？</strong></p><ul><li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如：顺序、循环；</li><li>多线程环境下，线程切换时，程序计数器用于记录当前线程执行的位置。</li></ul><p>如果执行的是native方法，那么程序计数器记录的是undefined地址，只有执行Java代码时程序计数器记录的才是下一条指令的地址。</p><p><strong>虚拟机栈和本地方法栈为什么是私有的？</strong></p><ul><li><strong>虚拟机栈</strong>：虚拟机栈由一系列帧（<code>Frame</code>）组成，每个方法调用都会创建一个帧，并将其推入虚拟机栈顶。每个帧包含了一个方法的局部变量表（<code>Local Variable Table</code>）、操作数栈（<code>Operand Stack</code>）、常量池引用等信息。</li><li><strong>本地方法栈：</strong>与虚拟机栈作用相似，区别在于虚拟机栈为虚拟机执行Java方法服务，本地方方法栈为虚拟机使用到的Native方法服务。在<code>HotSpot</code>中虚拟机栈和本地方法栈合二为一。</li></ul><p><strong>堆和方法区</strong></p><p>堆和方法区是所有线程共享的资源。堆是进程中最大的一块内存，主要用于存放新创建的对象。方法区主要用于存放已被加载的类信息、常量、静态变量等数据。</p><h1 id="2-Java线程和OS线程"><a href="#2-Java线程和OS线程" class="headerlink" title="2 Java线程和OS线程"></a>2 Java线程和OS线程</h1><p>JDK1.2 之前，Java线程基于绿色线程（Green Treads）实现，而不依赖于操作系统，是一种用户级线程。 </p><p>JDK1.2 及之后，Java线程改为基于原生线程（Native Threads）实现，由操作系统内核进行线程的调度和管理。</p><p>用户线程创建和切换成本低，但不可以利用多核；内核态线程，创建和切换成本高，可以利用多核。</p><p><strong>现在的Java线程本质其实就是操作系统的线程。</strong>                                                                                                       </p><p>常见三种线程模型：</p><img src="image-20240206162405236.png" alt="image-20240206162405236" style="zoom:50%;" /><p>在Windows和Linux系统中，Java线程采用一对一的线程模型，<em>Solaris系统</em> 是一个特例，HotSpot VM在Solaris上支持多对多和一对一。</p><h1 id="3-同步和异步的区别"><a href="#3-同步和异步的区别" class="headerlink" title="3 同步和异步的区别"></a>3 同步和异步的区别</h1><p><strong>同步：</strong>发出一个调用后，没有得到结果之前，该调用就不可以返回，一直等待。</p><p><strong>异步：</strong>调用发出后，不用等待即返回结果，调用直接返回。</p><h1 id="4-为什么要使用多线程"><a href="#4-为什么要使用多线程" class="headerlink" title="4 为什么要使用多线程"></a>4 为什么要使用多线程</h1><p>从总体上说：</p><ul><li><strong>从计算机底层：</strong>线程是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程，多核CPU意味着多个线程可以同时运行，从而减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势：</strong>多线程并发编程是开发高并发系统的基础，可以大大提高系统整体的并发能力以及性能。</li></ul><p>从计算机底层来讨论：</p><ul><li><strong>单核时代：</strong>单核时代多线程可以提高CPU和IO系统的效率。从而提高了Java进程利用系统资源的整体效率。</li><li><strong>多核时代：</strong>多核时代多线程可以提高进程利用多核CPU的能力。</li></ul><h1 id="5-多线程可能带来的问题"><a href="#5-多线程可能带来的问题" class="headerlink" title="5 多线程可能带来的问题"></a>5 多线程可能带来的问题</h1><p>内存泄漏、死锁、线程不安全等。</p><h1 id="6-如何理解线程安全和不安全"><a href="#6-如何理解线程安全和不安全" class="headerlink" title="6 如何理解线程安全和不安全"></a>6 如何理解线程安全和不安全</h1><ul><li><strong>线程安全</strong>指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的<strong>一致性</strong>和<strong>正确性</strong>。</li><li><strong>线程不安全</strong>表示在多线程环境下，对于同一份数据，多个线程同时访问时可能导致<strong>数据混乱</strong>、<strong>错误</strong>或者<strong>丢失</strong>。</li></ul><h1 id="7-单核CPU上运行多个线程效率一定会高吗？"><a href="#7-单核CPU上运行多个线程效率一定会高吗？" class="headerlink" title="7 单核CPU上运行多个线程效率一定会高吗？"></a>7 单核CPU上运行多个线程效率一定会高吗？</h1><p><strong>CPU密集型线程</strong>主要进行计算和逻辑处理，需要大量的CPU资源；<strong>IO密集型线程</strong>主要进行输入输出操作，需要等待IO设备的相应，而不需要占用太多的CPU资源。</p><p>单核CPU上，同一时刻只能有一个线程在运行。</p><p>如果线程是CPU密集型的，多个线程同时运行时会竞争CPU资源，导致<strong>频繁的线程切换</strong>，增加了系统开销，降低了效率。</p><p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在<strong>等待IO时</strong>的空闲时间，提高了效率。</p><h1 id="8-Java线程的生命周期和状态"><a href="#8-Java线程的生命周期和状态" class="headerlink" title="8 Java线程的生命周期和状态"></a>8 Java线程的生命周期和状态</h1><ul><li><strong>NEW</strong>: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li><strong>RUNNABLE</strong>: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li><li><strong>WAITING</strong>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>TIME_WAITING</strong>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕。</li></ul><img src="image-20240206204346161.png" alt="image-20240206204346161" style="zoom:67%;" /><ul><li>在操作系统层面，线程有READY和RUNNING状态（READY的线程获得CPU时间片后就处于RUNNING状态）；而在JVM层面，只有RUNNABLE状态。</li><li>线程执行<code>wait()</code>后，进入<code>WAITING</code>状态，需要依靠其他线程的通知才能够返回到运行状态。</li><li><code>TIMED_WAITING</code>状态相当于在等待状态的基础上增加了<strong>超时限制</strong>，可以通过执行<code>sleep(long millis)</code>方法或者<code>wait(long millis)</code>方法将线程置于<code>TIMED_WAITING</code>状态，超时时间结束后，线程将会返回到<code>RUNNABLE</code>状态。</li><li>当线程进入<code>synchronized</code>方法&#x2F;块，或者调用<code>wait</code>后（被<code>notify</code>）重新进入<code>synchronized</code>方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入<strong>BLOCKED（阻塞）</strong>状态。</li><li>线程执行完了<code>run()</code>方法之后将会进入<strong>TERMINATED（终止）</strong>状态。</li></ul><h1 id="9-线程上下文切换"><a href="#9-线程上下文切换" class="headerlink" title="9 线程上下文切换"></a>9 线程上下文切换</h1><p>当出现如下情况时，线程将会从占用CPU状态中退出：</p><ul><li>主动让出CPU，例如调用<code>sleep</code>方法或者<code>wait</code>方法等。</li><li>时间片用完。</li><li>调用了阻塞类型的系统中断，比如请求IO、线程被阻塞。</li><li>被终止或者结束运行。</li></ul><p>其中前三种将会导致线程上下文切换。</p><h1 id="10-死锁"><a href="#10-死锁" class="headerlink" title="10 死锁"></a>10 死锁</h1><p><strong>死锁的四个必要条件</strong></p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>预防死锁</strong></p><p>破坏四个必要条件。</p><p><strong>避免死锁</strong></p><p>在资源分配时，借助于算法（例如银行家算法）对资源分配进行计算评估，使系统进入安全状态。</p><h1 id="11-sleep和wait方法的比较"><a href="#11-sleep和wait方法的比较" class="headerlink" title="11 sleep和wait方法的比较"></a>11 sleep和wait方法的比较</h1><p><strong>共同点：</strong>都可以暂停线程的执行。</p><p><strong>区别：</strong></p><ul><li><code>sleep()</code>方法不释放锁，而<code>wait</code>方法释放锁。</li><li><code>sleep</code>通常用于暂停执行，<code>wait</code>通常用于线程间交互&#x2F;通信。</li><li><code>wait</code>方法调用后，线程不会自动苏醒，需要其他线程调用同一个对象上的<code>notify</code>或者<code>notifyAll</code>方法。<code>sleep</code>方法执行完成后，线程会自动苏醒，或者使用重载的<code>wait(long timeout)</code>方法超时后线程会自动苏醒。</li><li><code>sleep</code>是<code>Thread</code>类的静态本地方法，<code>wait</code>则是<code>Object</code>类的本地方法。</li></ul><h1 id="12-为什么wait方法不定义在Thread中"><a href="#12-为什么wait方法不定义在Thread中" class="headerlink" title="12 为什么wait方法不定义在Thread中"></a>12 为什么wait方法不定义在Thread中</h1><p>每个对象（<code>Object</code>）都有对象锁，<code>wait</code>方法是让获得对象锁的线程等待，将会自动释放当前线程占有的对象锁并将其进入<code>WAITING</code>状态。因此要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p><code>sleep</code>是让当前线程暂停执行，不涉及对象类，也不需要获得对象锁。</p><h1 id="13-可以直接调用Thread类的run方法吗？"><a href="#13-可以直接调用Thread类的run方法吗？" class="headerlink" title="13 可以直接调用Thread类的run方法吗？"></a>13 可以直接调用Thread类的run方法吗？</h1><ul><li>调用start方法，将会启动一个线程并使线程进入就绪状态，当分配到时间片后即开始运行。start会执行线程的相应准备工作，然后自动执行run方法。</li><li>直接执行run方法，将会把run方法当做一个main线程下的普通方法执行，而不会在某个线程中执行它，所以不是真正的多线程工作。</li></ul><p><strong>总结：调用start方法可启动线程并使线程进入就绪状态，直接执行run方法不会以多线程的方式执行。</strong></p><h1 id="14-JMM（Java内存模型）"><a href="#14-JMM（Java内存模型）" class="headerlink" title="14 JMM（Java内存模型）"></a>14 JMM（Java内存模型）</h1><h1 id="15-volatile关键字"><a href="#15-volatile关键字" class="headerlink" title="15 volatile关键字"></a>15 volatile关键字</h1><p><strong>如何保证变量的可见性</strong></p><blockquote><p><strong>可见性</strong>：每一个线程都保存了自己所使用的变量的副本，当修改某个变量的值时，不一定会立刻将修改写回主存，这就可能导致其他线程无法立即看到该变量的最新值，从而造成可见性问题。</p></blockquote><p><code>volatile</code>关键字可以保证变量的可见性，声明为<code>volatile</code>的变量将告诉JVM，这个变量是共享且不稳定的，<strong>每次</strong>使用它都需要到<strong>主存</strong>中进行读取。</p><img src="jmm.png" alt="JMM(Java 内存模型)" style="zoom: 80%;" /><p><code>volatile</code>关键字最原始的意义是禁用CPU缓存。能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>关键字既能保证可见性也能保证原子性。</p><p><strong>如何禁止指令重排序</strong></p><p><code>volatile</code>关键字除了可以保证变量的可见性，还可以防止JVM的指令重排序。</p><p>volatile在对这个变量进行读写操作时候，会通过插入特定的<strong>内存屏障</strong>的方式来禁止指令重排序。</p><p>Java的<code>unsafe</code>类提供了三个内存屏障相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fullFence</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>理论上，通过这三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果（只是会麻烦一些）。</p><p><strong>双重校验锁实现对象单例（线程安全）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码，这样可以减少对同步块的访问，从而提高了性能。</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上，<code>uniqueInstance = new Singleton();</code>这段代码其实分为三步执行：</p><ol><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存空间</li></ol><p>由于JVM具有指令重排的特性，上述三步的执行顺序可能变成 1-3-2，这在单线程环境下没有问题，但在多线程环境下，可能导致线程获得一个还未初始化的实例：线程A执行了第一步和第三步后，线程B调用<code>getUniqueInstance</code>方法后发现<code>uniqueInstance</code>不为空，直接将未初始化的<code>uniqueInstance</code>返回。</p><p><strong>volatile可以保证原子性吗</strong></p><p><code>volatile</code>可以保证变量的可见性，但是<strong>不能保证</strong>对变量的操作是原子性的。例如：</p><p>声明变量<code>inc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">inc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>声明方法对<code>inc</code>进行自增操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;<br>inc++;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>inc++</code>本身并不是原子操作，而是一个复合操作：</p><ol><li>读取<code>inc</code>的值</li><li>将<code>inc</code>加1</li><li>将<code>inc</code>的值写回内存</li></ol><p>当多线程并发调用<code>increase</code>方法时，最后Inc的值往往小于预期。</p><p>可以使用<code>synchronized</code>关键字进行改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;<br>inc++;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="16-乐观锁和悲观锁"><a href="#16-乐观锁和悲观锁" class="headerlink" title="16 乐观锁和悲观锁"></a>16 乐观锁和悲观锁</h1><ul><li><strong>悲观锁</strong>：共享资源每次只给一个线程使用，其它线程阻塞。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁都是悲观锁思想实现。<ul><li>高并发场景下，激烈的锁竞争会造成线程阻塞，大量的上下文切换，增加系统的性能开销，还可能存在死锁。</li></ul></li><li><strong>乐观锁</strong>：认为共享资源每次被访问都不会出现问题，线程可以不停地执行，不需要加锁也不需要等待，只在提交修改的时候验证对应的资源是否被其它线程修改（版本号机制或<code>CAS</code>算法）。<ul><li>不存在死锁问题，不存在锁竞争导致的线程阻塞，性能更高。</li><li>当写占比非常高的时候，将会导致频繁的失败和重试，影响性能。</li></ul></li></ul><h2 id="16-1-乐观锁实现"><a href="#16-1-乐观锁实现" class="headerlink" title="16.1 乐观锁实现"></a>16.1 乐观锁实现</h2><p><strong>版本号机制</strong></p><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数，当数据被修改的时候，<code>version</code>值加一。</p><p>线程A要更新数据时，读取数据的同时读取<code>version</code>值，提交更新结果时，对比刚刚读取到的<code>version</code>和数据库中的<code>version</code>值，当两者相等时执行更新，否则重试更新操作，直到成功（可以有效防止线程A覆盖线程B的更新）。</p><p><strong>CAS算法</strong></p><ul><li>全称<code>Compare And Swap</code>，应用更加广泛。</li><li>是一个原子操作，底层依赖于一条CPU原子指令。</li><li>思想：将预期值和要更新的变量值进行比较，两值相等时可以更新。<ul><li>V：<code>Var</code>，要更新的变量值（旧值）</li><li>E：<code>Expected</code>，预期值</li><li>N：<code>New</code>，新值</li><li>栗子：线程 A 要修改变量 i 的值为 6，i 原值为 1，则V &#x3D; 1，E&#x3D;1，N&#x3D;6</li></ul></li><li>多个线程同时使用CAS操作一个变量时，只有一个线程会成功，其它线程被通知失败，但并不会被挂起。</li><li>java语言没有实现CAS，通过C++内联汇编的形式实现。</li></ul><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapLong</code>、<code>compareAndSwapInt</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  CAS</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> o         包含要修改field的对象</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> offset    对象中某field的偏移量，可以通过反射获得</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> expected  期望值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> update    更新值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span>          true | false</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,  Object expected, Object update)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> update)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> update)</span>;<br></code></pre></td></tr></table></figure><h2 id="16-2-乐观锁存在的问题"><a href="#16-2-乐观锁存在的问题" class="headerlink" title="16.2 乐观锁存在的问题"></a>16.2 乐观锁存在的问题</h2><p><strong>①ABA问题</strong></p><p>描述：一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，则不能说明V的值没有被其它线程修改过，因为在这段时间它的值可能被改为其他值，然后又改回 A，而 CAS 操作会误认为它从来没有被修改过。</p><p>解决：给变量追加版本号或者时间戳。例如<code>AtomicStampedReference</code>类（JDK1.5之后）就是用来解决ABA问题的，其中<code>compareAndSet</code>方法既要检查引用是否相同也要检查标志是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>②循环时间长开销大</strong></p><p>CAS经常使用自旋操作进行重试，也就是不成功就一直循环执行直到成功，这将产生较大的CPU开销。</p><p>如果JVM能够支持处理器的<code>pause</code>指令，那么效率将会提升很多。</p><p><strong>③只能保证一个共享变量的原子操作</strong></p><p>CAS 只对单个共享变量有效，当操作涉及多个共享变量时 CAS 无法处理。</p><p>从JDK1.5 开始，可以借助<code>AtomicReference</code>类，将多个变量包装在一个对象里进行CAS操作，来保证引用对象之间的原子性。</p><h1 id="17-synchronized关键字"><a href="#17-synchronized关键字" class="headerlink" title="17 synchronized关键字"></a>17 synchronized关键字</h1><p><code>synchronized</code>关键字主要解决多个线程之间访问资源的同步性问题，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h2 id="17-1-使用synchronized"><a href="#17-1-使用synchronized" class="headerlink" title="17.1 使用synchronized"></a>17.1 使用synchronized</h2><p><strong>1、修饰实例方法（非静态方法）</strong></p><p>给当前对象实例加锁，进入同步代码前需要获得当前对象实例的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、修饰静态方法</strong></p><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码前需要获得当前class的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不难理解，一个线程A可以同时调用一个实例对象的非静态<code>synchronized</code>方法 以及 该对象所属类的静态<code>synchronized</code>方法。只要该线程同时获得对象锁和类锁即可。</p><p><strong>3、修饰代码块</strong></p><p>对括号中指定的对象&#x2F;类加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：尽量不要使用<code>synchronized(String a)</code>因为JVM中，字符串常量池具有缓存功能。</strong></p><h2 id="17-2-构造方法和synchronized"><a href="#17-2-构造方法和synchronized" class="headerlink" title="17.2 构造方法和synchronized"></a>17.2 构造方法和synchronized</h2><p>构造方法<strong>不能使用synchronized</strong>关键字修饰</p><p>而且，构造方法本身就是线程安全的。</p><h2 id="17-3-synchronized底层原理"><a href="#17-3-synchronized底层原理" class="headerlink" title="17.3 synchronized底层原理"></a>17.3 synchronized底层原理</h2><p><strong>修饰同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;synchronized 代码块&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>monitorenter</code>和<code>monitorexit</code>指令实现。</p><p><strong><img src="/image-20240218174821049.png" alt="image-20240218174821049"></strong></p><p>通过字节码可以看到，同步代码块使用了一个<code>monitorenter</code>和两个<code>monitorexit</code>，<code>monitorenter</code>指明同步代码块开始位置，<code>monitorexit</code>指明结束位置。需要两个<code>monitorexit</code>是为了保证代码在正常执行及异常情况下都能被正确释放。</p><p>执行<code>monitorenter</code>指令，线程将尝试获取锁也就是获取对象监视器<code>monitor</code>的持有权。</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<code>ObjectMonitor</code>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><p>如果锁的计数器为0则表示锁可以被获取，线程获取后将锁计数器加1；获取对象锁失败，当前线程阻塞等待，直到锁被另外一个线程释放。</p><p>对象锁的拥有者才可以执行<code>monitorexit</code>指令。执行后释放锁，将锁计数器设置为0，表明锁被释放。</p><p><strong>修饰同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;synchronized 方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看字节码可以发现，<code>synchronized</code>修饰的方法没有<code>monitorenter</code>和<code>monitorexit</code>指令，而是有一个<code>ACC_SYCHRONIZED</code>标识，指明该方法是一个同步方法，需要JVM执行相关的同步调用。</p><p><strong>无论是修饰同步代码块还是同步方法，两者的本质都是对对象监视器monitor的获取。</strong></p><h2 id="17-4-JDK1-6之后的synchronized"><a href="#17-4-JDK1-6之后的synchronized" class="headerlink" title="17.4 JDK1.6之后的synchronized"></a>17.4 JDK1.6之后的synchronized</h2><p>Java 6之后，<code>synchronized</code>引入大量优化，例如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术以减少锁开销，提升了<code>synchronized</code>锁的效率（在JDK 8中，偏向锁被彻底放弃）。</p><p>锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这是为了提高获得锁和释放锁的效率。</p><h2 id="17-5-synchronized和volatile区别"><a href="#17-5-synchronized和volatile区别" class="headerlink" title="17.5 synchronized和volatile区别"></a>17.5 synchronized和volatile区别</h2><p>两者的关系通常认为是互补的。</p><ul><li><code>volatile</code>关键字是线程同步的轻量级实现，性能优于<code>synchronized</code>。</li><li><code>volatile</code>只用于变量而<code>synchronized</code>关键字可以修饰方法和代码块。</li><li><code>volatile</code>关键字能保证数据的可见性，但是不能保证原子性。<code>synchronized</code>关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量的可见性问题，<code>synchronized</code>关键字解决线程之间的同步性问题。</li></ul><h1 id="18-ReentrantLock"><a href="#18-ReentrantLock" class="headerlink" title="18 ReentrantLock"></a>18 ReentrantLock</h1><ul><li><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，是一个<strong>可重入</strong>且<strong>独占</strong>的锁。</p></li><li><p><code>ReentrantLock</code>和<code>synchronized</code>关键字类似，但<strong>更加灵活、强大</strong>，增加了轮询、超时、中断、公平锁和非公平锁等功能。</p></li><li><p><code>ReentrantLock</code>有一个内部类<code>Sync</code>，<code>Sync</code>继承自<code>AQS(AbstractQueuedSynchronizer)</code>，<code>Sync</code>有公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>两个子类。</p></li><li><p>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="18-1-公平锁和非公平锁的区别"><a href="#18-1-公平锁和非公平锁的区别" class="headerlink" title="18.1 公平锁和非公平锁的区别"></a>18.1 公平锁和非公平锁的区别</h2><ul><li><strong>公平锁</strong>：锁释放后，先申请的进程先得到锁，保证时间上的绝对顺序，上下文切换较为频繁。</li><li><strong>非公平锁：</strong>锁释放后，按其他规则（例如优先级）来分配锁，而不是时间顺序。性能更好，但可能导致某些进程永远无法获得锁。</li></ul><h2 id="18-2-synchronized和ReentrantLock的区别"><a href="#18-2-synchronized和ReentrantLock的区别" class="headerlink" title="18.2 synchronized和ReentrantLock的区别"></a>18.2 synchronized和ReentrantLock的区别</h2><ul><li><p>两者<strong>都是可重入锁</strong></p><ul><li>可重入锁：又称为递归锁，指的是线程可以再次获得自己已经持有的锁，而不会产生死锁。</li><li>JDK 提供的所有现成的<code>Lock</code>实现类，包括<code>synchronized</code>关键字锁都是可重入的。</li></ul></li><li><p><strong>synchronized依赖于JVM而ReentrantLock依赖于API</strong></p></li><li><p><strong>ReentrantLock需要手动加锁、解锁</strong></p><ul><li><code>synchronized</code> 关键字是自动进行加锁、解锁的，而 <code>ReentrantLock</code> 需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成，来手动加锁、解锁。</li></ul></li><li><p><strong>ReentrantLock支持设置锁超时时间</strong></p></li><li><p><code>ReentrantLock</code>比<code>synchronized</code>增加了一些高级功能：</p><ul><li><strong>等待可中断：</strong>通过<code>lock.lockInterruptibly</code>可以使得正在等待的线程放弃等待，转而执行其他事情。</li><li><strong>可实现公平锁：</strong><code>synchronized</code>只能是非公平锁，而<code>ReentrantLock</code>可以指定。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）：</strong><code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类也可以实现，需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul></li></ul><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h2 id="18-3-可中断锁和不可中断锁的区别"><a href="#18-3-可中断锁和不可中断锁的区别" class="headerlink" title="18.3 可中断锁和不可中断锁的区别"></a>18.3 可中断锁和不可中断锁的区别</h2><ul><li>可中断锁：申请锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。例如<code>ReentrantLock</code>。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他逻辑处理。例如<code>synchronized</code>。</li></ul><h1 id="19-ReentrantReadWriteLock（了解）"><a href="#19-ReentrantReadWriteLock（了解）" class="headerlink" title="19 ReentrantReadWriteLock（了解）"></a>19 ReentrantReadWriteLock（了解）</h1><p>JDK1.8 中引入了性能更好的读写锁<code>StampedLock</code></p><h2 id="19-1-概念"><a href="#19-1-概念" class="headerlink" title="19.1 概念"></a>19.1 概念</h2><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个<strong>可重入</strong>的<strong>读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span>, java.io.Serializable&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一般锁默认是读读互斥、写写互斥、读写互斥</li><li>读写锁默认是<strong>读读不互斥</strong>、写写互斥、读写互斥</li></ul><p>可以看到，<code>ReentrantReadWriteLock</code>其实是<code>WriteLock</code>和<code>ReadLock</code>两把锁。读锁是共享锁，可以同时被多个线程持有，写锁是独占锁，最多只能同时被一个线程持有。</p><ul><li>共享锁：一把锁可以被多个线程同时获得。</li><li>独占锁：一把锁只能被一个线程获得。</li></ul><p>和<code>ReentrantLock</code>一样，<code>ReentrantReadWriteLock</code>底层基于<code>AQS</code>实现。</p><p>和ReentrantLock完全一样，<code>ReentrantReadWriteLock</code>支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器显示指定。</p><h2 id="19-2-使用场景"><a href="#19-2-使用场景" class="headerlink" title="19.2 使用场景"></a>19.2 使用场景</h2><p>读多写少的情况下，<code>ReentrantReadWriteLock</code>可以明显提升系统性能。</p><h2 id="19-3-线程可以同时持有读锁和写锁吗？"><a href="#19-3-线程可以同时持有读锁和写锁吗？" class="headerlink" title="19.3 线程可以同时持有读锁和写锁吗？"></a>19.3 线程可以同时持有读锁和写锁吗？</h2><p><a href="https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw">聊聊 Java 的几把 JVM 级锁 (qq.com)</a></p><ul><li>有读锁时，不能再获取写锁（其实是因为，只要读锁被占用，写锁就不能获取，不论读锁是否是当前线程所持有）</li><li>有写锁时，该线程可以继续获取读锁（而当写锁不是当前线程占用时，获取读锁也会失败）。</li></ul><h2 id="19-4-读锁为什么不能升级为写锁？"><a href="#19-4-读锁为什么不能升级为写锁？" class="headerlink" title="19.4 读锁为什么不能升级为写锁？"></a>19.4 读锁为什么不能升级为写锁？</h2><ol><li>写锁可以降级为读锁，但是读锁不能够升级为写锁，因为写锁是独占锁，读锁升级为写锁将会引起线程争夺，会影响性能。</li><li>可能导致死锁：两个线程的读锁同时想要升级为写锁，则需要双方都释放自己的锁，而两者都不释放，就会产生死锁。</li></ol><h1 id="20-StampedLock（了解）"><a href="#20-StampedLock（了解）" class="headerlink" title="20 StampedLock（了解）"></a>20 StampedLock（了解）</h1><p>JDK 1.8引入的性能更好的读写锁，<strong>不可重入</strong>，<strong>不支持</strong>条件变量<code>Condition</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。<strong>类似于 <code>ReentrantReadWriteLock</code> 的写锁</strong>，不过这里的写锁是不可重入的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。<strong>类似于 <code>ReentrantReadWriteLock</code> 的读锁</strong>，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li></ul><p><code>StampedLock</code>也支持这三种锁相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToWriteLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToReadLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToOptimisticRead</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><h2 id="20-1-StampedLock性能为什么更好"><a href="#20-1-StampedLock性能为什么更好" class="headerlink" title="20.1 StampedLock性能为什么更好"></a>20.1 StampedLock性能为什么更好</h2><p><code>StampedLock</code>乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，当读多写少的时候，写线程有机会获取写锁，减少线程饥饿的问题，大大提高吞吐量。</p><h2 id="20-2-StampedLock适合的场景"><a href="#20-2-StampedLock适合的场景" class="headerlink" title="20.2 StampedLock适合的场景"></a>20.2 StampedLock适合的场景</h2><p>读多写少，可以作为<code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>但是，和<code>ReentrantLock</code>相比，不可重入，不支持<code>Condition</code>，对中断操作的支持也不够友好。</p><h1 id="21-Atomic原子类"><a href="#21-Atomic原子类" class="headerlink" title="21 Atomic原子类"></a>21 Atomic原子类</h1><p><a href="https://javaguide.cn/java/concurrent/atomic-classes.html">Atomic 原子类总结 | JavaGuide</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
